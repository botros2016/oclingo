\section{Restrictedness Notions}\label{sec:restricted}

\begin{oldstuff}
In view of function symbols with non-zero arity,
we may be confronted with logic programs over an infinite Herbrand base.
In order to maintain decidability of reasoning tasks,
it is thus important to identify language fragments for which
finite equivalent ground programs are guaranteed to exist.
Level-restricted logic programs constitute such a fragment,
where finiteness is manifested in the requirement that any variable in a rule
must be bound to a finite set of ground terms via a predicate not
subject to positive recursion through that rule.
The notion of level-restrictedness is complemented by stratification,
which by disallowing negative recursion among predicates describes a
class of logic programs having unique answer sets.
The formal definition of level-restricted programs,
which can be grounded by \gringo\ (stand-alone or embedded in \clingo\ and \iclingo),
is provided in Section~\ref{subsec:lambda}.
Section~\ref{subsec:strat} introduces stratified programs and the related
concept of domain predicates, which can serve particular purposes during grounding.
Both sections may be skimmed or even skipped upon the first reading,
and rather be looked up later on to find out details.
\end{oldstuff}

\begin{newstuff}
In order to apply a grounding algorithm to a logic program,
we have to impose certain restrictions on the input format.
We will allow for a very general class of logic programs,
so called safe programs,
that give us a lot of modeling flexibility.
In fact, \gringo-3.0's new input language is Turing-complete.
This implies that in contrast to previous versions\comment{refer to appendix},
the grounding is no longer guaranteed to be finite
and thus the grounding algorithm will not necessarily halt.
On first sight this might seem to be a disadvantage but is compensated by the fact 
that much more interesting problems, often in a more concise way, can be represented now.
For example, we can run some calculation till a certain fix-point is reached.
This has not been possible before and frequently workarounds were needed, e.g, 
large domains that provide the necessary values to perform the desired calculation.
With safe programs such values can be calculated on demand,
which often prevents space explosion, and also keeps the encoding more compact.
The formal definition of safe programs programs,
which can be grounded by \gringo\ (stand-alone or embedded in \clingo\ and \iclingo),
is provided in Section~\ref{subsec:safe}.
Section~\ref{subsec:strat} introduces stratified programs and the related
concept of domain predicates, which can serve particular purposes during grounding.
Both sections may be skimmed or even skipped upon the first reading,
and rather be looked up later on to find out details.
\end{newstuff}

\begin{oldstuff}
\subsection{Level-Restricted Logic Programs}\label{subsec:lambda}

The main task of a grounder is to substitute the variables in a logic program~$\Pi$
by terms such that the result is a finite equivalent ground program~$\alt{\Pi}$.%
\footnote{$\Pi$ and~$\alt{\Pi}$ are equivalent if they have the same answer sets.}
Of course, a necessary condition for this is that~$\Pi$ possesses
only finitely many finite answer sets.
Unfortunately, such a property is undecidable in general~\cite{daeigovo01a}.
Instead of semantic properties, grounders do thus impose rather simple syntactic
conditions to guarantee the existence of finite equivalent ground programs
(which are then also computed).
For instance, the \dlv\ system~\cite{dlv03a} requires programs to be \emph{safe} for
establishing finiteness in the absence of functions with non-zero arity and under
limited arithmetic.
Grounder \lparse~\cite{lparseManual} deals with \emph{$\omega$-restricted}
programs~\cite{syrjanen01a}, which are more restrictive than safe programs
but guarantee finiteness also in the presence of functions with non-zero arity.
Finally, \gringo~\cite{gescth07a} requires programs to be \emph{$\lambda$-restricted},
a property more general than $\omega$-restrictedness but likewise applicable
to programs over the same languages.
We below reproduce the concept of $\lambda$-restrictedness,
called level-restrictedness here.

The idea underlying level-restrictedness is that the structure of a logic program~$\Pi$
must be such that, for each rule $r\in\Pi$,
the set of potentially applicable ground instances of~$r$ is known in advance.
This is the case if, for each variable~$V\in\vars{r}$,
we find an atom~$A$ in the body of~$r$ with
$V\in\vars{A}$ (where $\vars{A}$ is that set of variables occurring in~$A$)
such that the potentially derivable ground instances of~$A$ are limited (see below).
In fact, with such an atom~$A$ at hand,
the set of ground terms to which~$V$ needs to be instantiated is known a priori,
and no further ground terms need to be considered.
The sketched approach is justified by the $\subseteq$-minimality of answer sets
in the sense of Section~\ref{subsec:semantics},
as it allows us to restrict the attention to rules whose bodies are derivable w.r.t.\
some answer set.
Beyond outputting only ``relevant rules,''
grounders can apply answer-set preserving simplifications,
some of which are discussed in Section~\ref{subsec:strat}.

We next provide a more precise account of level-restrictedness,
where we start by considering normal programs~$\Pi$.
For a rule $r\in\Pi$ and $V\in\vars{r}$,
we let $\binders{V}{r}$ contain all elements of~$\pbody{r}$ that may be used to
limit~$V$ to a certain subset of~$\ground{\mathcal{T}}$.
Although some exceptions will be explained later on,
% for normal rules~$r$ of form~(\ref{eq:normal:rule}),
it is convenient to assume that $\binders{V}{r}$ consists of all atoms $A\in\pbody{r}$
such that $V\in\vars{A}$.
We then % consider level mappings $\lambda$ and 
define~$\Pi$ as \emph{level-restricted}
if there is some level mapping~$\lambda:\mathcal{P}\rightarrow\mathbb{N}$ such that,%
\footnote{Recall that $\mathcal{P}$ is the set of all predicates that occur in~$\Pi$.}
for every rule~$r\in\Pi$ and each $V\in\vars{r}$,
there is some $A\in\binders{V}{r}$ such that $\lambda(p/i)>\lambda(q/j)$
for predicate~$p/i$ of $\head{r}$ and predicate~$q/j$ of~$A$.
Note that an appropriate~$\lambda$ (if it exists) is easy to determine,
and \gringo\ exploits it to schedule the order in which rules will be instantiated.
In fact, if rules are processed in the order of levels of their head predicates,
ground  terms to be substituted for variables can be restricted
on the basis of atoms identified as (un)derivable before.

\begin{example}\label{ex:lambda}
Consider the following logic program:
%
\lstinputlisting{examples/zigzag.lp}
%
The set~$\mathcal{P}$ of predicates contains
\pred{zig}/$1$, \pred{zag}/$1$,
\pred{zigzag}/$2$, and \pred{zagzig}/$2$.
The rules~$r$ with head predicates \pred{zig}/$1$ or \pred{zag}/$1$ in Line~1 and~2
are ground ($\vars{r}=\nolinebreak\emptyset$).
Hence, the level-restrictedness condition is trivially satisfied for these rules,
and we may map their head predicates by~$\lambda$ as follows:
$\pred{zig}/1 \mapsto 0$ and $\pred{zag}/1 \mapsto 0$.
For the rule in Line~3,
we have to respect that
$\lambda(\pred{zigzag}/2) > \lambda(\pred{zig}/1) = \lambda(\pred{zag}/1) =\nolinebreak 0$.
We can thus choose $\pred{zigzag}/2\mapsto 1$.
Also note that \code{\pred{zig}(\var{X})} and \code{\pred{zag}(\var{Y})} are
the only atoms in $\binders{\var{X}}{}$ and $\binders{\var{Y}}{}$, respectively.
Finally, we let $\pred{zagzig}/2\mapsto 2$ in view of the rule in Line~4,
where \code{\pred{zigzag}(\var{X},\var{Y})} belongs to
$\binders{\var{X}}{}$ and $\binders{\var{Y}}{}$.
The total mapping
\(
\lambda=
\{
\pred{zig}/1 \mapsto 0,
\pred{zag}/1 \mapsto 0,
\pred{zigzag}/2\mapsto 1,
\pred{zagzig}/2\mapsto 2
\}
\)
witnesses that the above program is level-restricted.

Note that the given mapping~$\lambda$ would no longer be appropriate
if we add rule
%
\begin{lstlisting}[firstnumber=5]
zigzag(X,Y) :- zagzig(Y,X).
\end{lstlisting}
%
In fact, the program consisting of all rules in Line~1--5 is not
level-restricted because Line~4 and~5 require
$\lambda(\pred{zagzig}/2) > \lambda(\pred{zigzag}/2)$ and
$\lambda(\pred{zigzag}/2) > \lambda(\pred{zagzig}/2)$, respectively.
Clearly, there cannot be any level mapping~$\lambda$ jointly
satisfying these two conditions.
However, replacing Line~4 with
%
\begin{lstlisting}[firstnumber=4]
zagzig(Y,X) :- zigzag(X,Y), zig(X), zag(Y).
\end{lstlisting}
%
would restore level-restrictedness because
\code{\pred{zig}(\var{X})} and \code{\pred{zag}(\var{Y})} belong to
$\binders{\var{X}}{}$ and $\binders{\var{Y}}{}$, respectively.
Instead of the previous~$\lambda$, the following level mapping could then be used:
\(
%\lambda=
\{
\pred{zig}/1 \mapsto 0,
\pred{zag}/1 \mapsto 0,
\pred{zagzig}/2\mapsto 1,
\pred{zigzag}/2\mapsto 2
\}
\).\nolinebreak
\eexample
\end{example}

The fundamental property of a level-restricted
program is that it admits a finite equivalent ground program, not to be confused with
the (full) ground instantiation because $\ground{\mathcal{T}}$ may still be infinite.
Furthermore, level-restrictedness provides a syntactic criterion that is not
difficult to check.
In fact, \gringo\ performs such a check and accepts an input program if it is level-restricted.
Generalizations of level-restrictedness to the rich input language of \gringo\
will be discussed in Section~\ref{sec:language}.
\end{oldstuff}

\begin{newstuff}
\subsection{Safe Logic Programs}\label{subsec:safe}

The main task of a grounder is to substitute the variables in a logic program~$\Pi$
by terms such that the result is a finite equivalent ground program~$\alt{\Pi}$.%
\footnote{$\Pi$ and~$\alt{\Pi}$ are equivalent if they have the same answer sets.}
Of course, a necessary condition for this is that~$\Pi$ possesses
only finitely many finite answer sets.
Unfortunately, such a property is undecidable in general~\cite{daeigovo01a}.
Instead of semantic properties, grounders do thus impose rather simple syntactic
conditions to guarantee the existence of finite equivalent ground programs
(which are then also computed).
For instance, the \dlv\ system~\cite{dlv03a} requires programs to be \emph{safe} for
establishing finiteness in the absence of functions with non-zero arity and under
limited arithmetic.
Grounder \lparse~\cite{lparseManual} deals with \emph{$\omega$-restricted}
programs~\cite{syrjanen01a}, which are more restrictive than safe programs
but guarantee finiteness also in the presence of functions with non-zero arity.
Previous \gringo~\cite{gescth07a} versions required programs to be \emph{$\lambda$-restricted},
a property more general than $\omega$-restrictedness but likewise applicable
to programs over the same languages.
Finally, recent \gringo\ versions and, e.g., \dlvcomplex~\comment{add reference} use \emph{safe programs}, 
which are a strict super set of \emph{$\lambda$-restricted} programs 
and, in constrast to \dlv\, do not limit arithmetics and also allow for using function symbols.
In this setting, it is no longer possibile to check
whether there is a finite grounding for a given program and 
thus a grounding algorithm need not necessarily hold on some inputs.

A logic program is safe if every variable in each rule occurs in some positive predicate of the rule.
In this case, we can apply \emph{semi-naive evaluation} \comment{add reference} to ground the logic program.
Whenever we ground a rule and see a new head, we can use this head to bind variables
in corresponding positive predicates to obtain new ground rules.
This process is repeated until no more new ground rules will be generated.
The sketched approach is justified by the $\subseteq$-minimality of answer sets
in the sense of Section~\ref{subsec:semantics},
as it allows us to restrict the attention to rules whose bodies are derivable w.r.t.\
some answer set.

\begin{example}\label{ex:safe}
Consider the following logic program:
%
\lstinputlisting{examples/zigzagx.lp}
%
The set~$\mathcal{P}$ of predicates contains
\pred{zig}/$1$, \pred{zag}/$1$,
and \pred{zigzag}/$2$.
The rules~$r$ with head predicates \pred{zig}/$1$ or \pred{zag}/$1$ in Line~1 and~2
are ground ($\vars{r}=\nolinebreak\emptyset$).
Hence, we immediately get the two ground rules
\begin{lstlisting}[firstnumber=1]
zigzag(0).
zigzag(1).
\end{lstlisting}
There are two new heads $\pred{zig}(0)$ and $\pred{zag}(1)$ that can be used to instantiate the third rule
\begin{lstlisting}[firstnumber=3]
zigzag(0,1) :- zig(0), zag(1).
\end{lstlisting}
This allows use to use $\pred{zigzag}(0,1)$ to instantiate the last rule
\begin{lstlisting}[firstnumber=4]
zigzag(1,0) :- zigzag(0,1).
\end{lstlisting}
We get a new head $\pred{zigzag}(1,0)$ that will be used to instantiate the same rule again
\begin{lstlisting}[firstnumber=5]
zigzag(0,1) :- zigzag(1,0).
\end{lstlisting}
At this point, no new heads have been generated and the grounding process stops.
\end{example}

\begin{example}\label{ex:unsafe}
Note that safety is a very intuitive concept.
Consider for example the following unsafe program
\begin{lstlisting}[firstnumber=1]
a(X) :- not b(Y).
\end{lstlisting}
Using an infinite Herbrand base, the above program neither has a finite instantiation nor a finite answer set
and we cannot apply the grounding algorithm sketched above.\comment{Refer to literature that covers such programs?}
\end{example}

The fundamental property of a safe
program is that it admits using the grounding algorithm sketched above 
and that it might yield a finite ground instantiation, not to be confused with
the (full) ground instantiation because $\ground{\Pi}$ may still be infinite.
Furthermore, safety provides a syntactic criterion that is not
difficult to check.
In fact, \gringo\ performs such a check and accepts an input program only if it is safe.
To generalize the notion of safety to the rich input language of \gringo,
we formalize safety using a directed \emph{variable graph} $G_r=(V \cup \{\$\},E)$
w.r.t. a rule~$r$.
The set~$V$ corresponds to the variables that occur in the rule and
the set of edges~$E \subseteq (V \cup \{\$\}) \times V$ connect variables 
or the special start node $\$$ with other variables.
Only positive predicates contribute to edges of the graph.
For every variable~$X$ that occurs in a positive literal of the rule there is an edge~$(\$,X)\in E$.
A rule~$r$ is safe if there is a level mapping $\lambda:V\cup\{\$\}\rightarrow\mathbb{N}$ 
and for every~$X \in V$ exits a~$Y \in V\cup\{\$\}$ 
such that $\lambda(X) < \lambda(Y)$ and $(X,Y) \in E$ for $G_r=(V \cup \{\$\}, E)$.
Finally, a logic program $\Pi$ is safe if all its rules are safe.
In Section~\ref{sec:language}, extensions to this graph will be dicussed
whenever new language constructs are introduced.
\end{newstuff}

\subsection{Stratified Logic Programs}\label{subsec:strat}

Another relevant restriction is stratification (cf.~\cite{minker88}),
as every stratified (normal) program has a unique answer.
Grounder \gringo\ exploits stratification in two respects:
first, it fully evaluates stratified (sub)programs during grounding, and second,
predicates that are subject to stratification can serve as domain predicates (see below).
Stratification can be characterized in terms
of level mappings, here, witnessing the absence of recursion through ``\code{not}.''
We start by introducing stratification on normal programs, and in a second step,
we consider stratified subprograms.

A normal program~$\Pi$ is \emph{stratified}
if there is some level mapping~$\xi:\mathcal{P}\rightarrow\mathbb{N}$ such that,
for every rule~$r\in\Pi$ and predicate~$p/i$ of~$\head{r}$, we have
\begin{itemize}
\item
$\xi(p/i)\geq\max\{\xi(q/j) \mid q(t_1,\dots,t_j)\in\pbody{r}\}$ ~and
\item
$\xi(p/i)>   \max\{\xi(q/j) \mid q(t_1,\dots,t_j)\in\nbody{r}\}$.
\end{itemize}
%
Observe that the levels of predicates in the positive body of a rule
can be equal to the level of the head predicate,
while the levels of predicates in the negative body must be strictly less.
That is, positive recursion is allowed among predicates of the same level,
but negative dependencies must obey a strict order.

\begin{example}\label{ex:strat:prog}
We construct a level mapping~$\xi$ for the predicates in the logic program:
%
\lstinputlisting{examples/strat.lp}
%
Observe that predicate \pred{bitter}/$1$ does not occur in the head on any rule, thus,
we may map
$\pred{bitter}/1 \mapsto 0$.
Furthermore, the facts in Line~1 and the rule in Line~2 do not have
a negative body, so that their head predicates can also be mapped to the lowest level:
$\pred{fruit}/1 \mapsto 0$,
$\pred{foul}/1 \mapsto 0$, and
$\pred{natural}/1 \mapsto\nolinebreak 0$.
We still have to map predicates \pred{healthy}/$1$ and \pred{tasty}/$1$.
As \pred{foul}/$1$ occurs in the negative body of the rule in Line~3,
we require 
$\xi(\pred{healthy}/1)>\xi(\pred{foul}/1)=0$.
We can thus choose 
$\pred{healthy}/1 \mapsto 1$.
Finally, the occurrence of \pred{healthy}/$1$ in the positive body of the rule in Line~4
necessitates $\xi(\pred{tasty}/1)\geq\xi(\pred{healthy}/1)=1$, realized by
$\pred{tasty}/1 \mapsto 1$.
In this way, we also satisfy $\xi(\pred{tasty}/1)>\xi(\pred{bitter}/1)=0$.
The obtained total mapping 
$
\xi
=
\{
\pred{bitter}/1 \mapsto 0,\linebreak[1]
\pred{fruit}/1 \mapsto 0,\linebreak[1]
\pred{foul}/1 \mapsto 0,\linebreak[1]
\pred{natural}/1 \mapsto 0,\linebreak[1]
\pred{healthy}/1 \mapsto 1,\linebreak[1]
\pred{tasty}/1 \mapsto 1
\}
$
witnesses that the above program is stratified.
As mentioned before, every stratified normal program has a unique answer set~$X$.
\marginlabel{%
By invoking\\
  \code{\mbox{~}gringo -t \textbackslash\\\mbox{~}examples/strat.lp}
the reader can observe that \gringo\ computes this unique answer set~$X$
and represents it in terms of facts.}
Here, we get
$
X
=
\{
\code{\pred{fruit}(\const{apple})},\linebreak[1]
\code{\pred{fruit}(\const{peach})},\linebreak[1]
\code{\pred{foul}(\const{peach})},\linebreak[1]
\code{\pred{natural}(\const{apple})},\linebreak[1]
\code{\pred{natural}(\const{peach})},\linebreak[1]
\code{\pred{healthy}(\const{apple})},\linebreak[1]
\code{\pred{tasty}(\const{apple})}
\}
$.

The program would no longer be stratified if we add rule
%
\begin{lstlisting}[firstnumber=5]
bitter(X) :- healthy(X), not tasty(X).
\end{lstlisting}
%
In fact, the conditions $\xi(\pred{tasty}/1)>\xi(\pred{bitter}/1)$
(because of Line~4) and $\xi(\pred{bitter}/1)>\xi(\pred{tasty}/1)$
(because of Line~5) cannot jointly be satisfied by any level mapping~$\xi$.
Note that the non-stratified program containing all rules in Line~1--5
has two answer sets: $X$ and
$(X\setminus\{\code{\pred{tasty}(\const{apple})}\})\cup\{\code{\pred{bitter}(\const{apple})}\}$.
\eexample
\end{example}

After dealing with stratified programs, we consider subprograms.
For a given logic program~$\Pi$, some~$\pi\subseteq\Pi$ is a 
\emph{stratified subprogram} of~$\Pi$ if
$\pi$ is stratified and if
no predicate~$p/i$ occurring in~$\pi$ belongs to the head of any rule in~$\Pi\setminus\pi$.
As a matter of fact,
a stratified normal subprogram~$\pi$ of~$\Pi$ has a unique answer set~$Y$ such that
$Y\subseteq X$ for any answer set~$X$ of~$\Pi$~\cite{liftur94a}.
A stratified subprogram~$\pi$ of~$\Pi$ is \emph{maximal} if every stratified
subprogram of~$\Pi$ is contained in~$\pi$.
Note that every logic program has a maximal stratified subprogram,
which is also easy to determine.
In fact, \gringo\ identifies the maximal stratified subprogram~$\pi$
of a logic program~$\Pi$,
and it fully evaluates the predicates~$p/i$ not belonging to the head of any rule in~$\Pi\setminus\pi$,
which we call \emph{domain predicates}.
In Section~\ref{subsec:gringo:condition},
we will see that domain predicates can serve particular purposes during grounding.

\begin{example}\label{ex:strat:max}
As the program in Line~1--4 of Example~\ref{ex:strat:prog} is stratified,
the maximal stratified subprogram consists of all rules.
After adding the rule in Line~5,
only the rules in Line~1--3 belong to the maximal stratified subprogram.
The corresponding domain predicates are
$\pred{fruit}/1$,
$\pred{foul}/1$,
$\pred{natural}/1$, and
$\pred{healthy}/1$, 
and the unique answer set for them is
$
Y
=
\{
\code{\pred{fruit}(\const{apple})},\linebreak[1]
\code{\pred{fruit}(\const{peach})},\linebreak[1]
\code{\pred{foul}(\const{peach})},\linebreak[1]
\code{\pred{natural}(\const{apple})},\linebreak[1]
\code{\pred{natural}(\const{peach})},\linebreak[1]
\code{\pred{healthy}(\const{apple})}
\}
$.
\eexample
\end{example}

Consider the safe, stratified (take $\xi=\{\pred{nat}/1 \mapsto 0\}$) program
\begin{lstlisting}[numbers=none]
nat(0).  nat(s(X)) :- nat(X).
\end{lstlisting}
In fact, the program has a unique but infinite answer set.
Thus,
the program cannot be translated to a finite equivalent ground program.
Nevertheless, \gringo\ would accept it, but it will not halt (assuming infinite memory).
Stratified subprograms can be exploited during instantiation
to optimize the grounding, e.g. facts in rule bodies need not be printed, and to make use of domain predicates, e.g., in aggregates~\comment{reference aggregates}.

